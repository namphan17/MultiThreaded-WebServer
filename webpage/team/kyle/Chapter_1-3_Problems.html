<!DOCTYPE html>
<html>
<head>
<title>
	Chapter 1-3 Problems
</title>
<style>
 	.indent{ padding-left: 25px
	}
</style>
</head>
<body class="indent">
	<h1>Chapter 1-3 Problems</h1>
	<!-- Indentation and text of the question added by Jeremy-->
	<p><b>Ch.2 P1: </b> True or False?<br>
	a. A user requests a Web page that consists of some text and three images. For this page, the client will send one request message and receive four response messages. <br>
	b. Two distinct webpages can be sent over the same persistent connection. <br>
	c. With nonpersistent connections between browser and origin server, it is possible for a singe TCP segment to carry two distinct HTTP request messages. <br>
	d. The <i>Date:</i> header in the HTTP response message indicates when the object in the response was last modified.<br>
	e. HTTP response messages never have an empty message body.<br><br>

	a. True <br>
	b. True <br>
	c. False <br>
	d. False <br>
	e. True 
	</p>
	<p><b>Ch.3 P3: </b>UDP and TCP use 1s complement for their checksums. Suppose you have the following three 8-bit bytes: 01010011, 01100110, 01110100. What is the 1s complement of the sum of these 8-bit bytes? (Note that although UDP and TCP use 16-bit words in computing the checksum, for this problem you are being asked to consider 8-bit sums.) Show all work. Why is it that UDP takes the 1s complement of the sum; that is, why not just use the sum? With the 1s complement scheme, how does the receiver detect errors? Is it possible that a 1-bit error will go undetected? How about a 2-bit error? 
	</p>
	<p style="font: monospace;"> 
	&nbsp; &nbsp;  1   11   <br>
	&nbsp; &nbsp; 01010011 <br>
	+ 01100110 <br>
	= 10111001 <br>
	           <br>
	&nbsp; &nbsp;   111   11 <br>
	&nbsp; &nbsp;   10111001 <br>
	+ 01110100 <br>
	= 00101110 <br>
               <br>
	1's compliment: 11010001 <br>
	<br>
	UDP takes the 1's compliment because when it is added to the sum, it should read 11111111. <br>
	If there is a zero, then there is an error.<br>
	It isn't possible for a 1 bit error to make it through, but a 2 bit error could if the 2 bits canceled each other out.<br>
	For example: if the last bit of the first byte was changed to a zero and the last bit of the second byte was changed to a 1, the result of the checksum would be the same.
	</p>
</body>
</html>
